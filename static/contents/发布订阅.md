# 发布订阅

发布订阅是一种消息通信模式，即发布者在更新内容时，订阅者可以立即收到通知，并进行处理。

- 发布者（Publisher） 只负责把消息发送到一个“中间人”（消息中心 / 事件总线），

- 订阅者（Subscriber） 提前告诉中间人自己想要哪类消息，

- 发布者和订阅者之间不直接通信，由中间人负责把消息分发给所有订阅了该消息的人。

## 发布订阅的作用

之所以要学习这套机制是因为该机制在非常多的场景中都有使用，无论是前端或者后端还是更广泛的领域：

- 前端响应式编程的核心就是发布订阅，在数据发生变化时同时更新并触发副作用
- 后端微服务之间的消息通信通常也是使用发布订阅实现的，如MQTT协议等

## 发布订阅的实现

这里从前端视角出发实现页面和数据的同步功能，现在让我们从一个简单案例开始吧，这段代码是最原始的`html + js`实现的，最终会通过发布订阅来实现相同的功能。

### 步骤一 原始实现

```html
<body>
	<!-- 定义HTML结构 -->
	<div>
		<div>
			<span>姓:</span>
			<input id="firstName" placeholder="请输入姓" />
		</div>
		<div>
			<span>名:</span>
			<input id="lastName" placeholder="请输入名" />
		</div>
		<div>
			<span>姓名: </span>
			<span id="fullName"></span>
		</div>
	</div>

	<!-- 操作脚本 -->
	<script>
		const firstName = document.getElementById('firstName');
		const lastName = document.getElementById('lastName');
		const fullName = document.getElementById('fullName');

		const data = {
			firstName: '',
			lastName: '',
			fullName: ''
		};

		/**
		 * 更新 fullName 数据
		 * 同时将数据更新到模版上
		 */
		function updateFullName() {
			data.fullName = data.firstName + data.lastName;
			fullName.innerText = data.fullName;
		}

		firstName.addEventListener('input', (e) => {
			data.firstName = e.target.value;
			// 触发更新
			updateFullName();
		});

		lastName.addEventListener('input', (e) => {
			data.lastName = e.target.value;
			// 触发更新
			updateFullName();
		});
	</script>
</body>
```

以下是功能展示，当用户输入`姓`和`名`字段时，`姓名`字段的内容也会同步更新。

<iframe src="/frame/发布订阅1" class="shadow-lg border border-gray-200 w-full h-auto p-10" ></iframe>

### 步骤二 保持同步

那上述代码存在什么问题呢？如果我们在脚本中执行`data.firstName = "姓"`，页面上的`姓`和`姓名`两个字段的内容都是不能显示你的姓的，那如何才能让它按照我们设想中的那样执行呢？

这就要使用`Proxy`这个对象了，该对象可以让监听到对象属性的变化。

```html
<body>
	<div>
		<div>
			<span>姓:</span>
			<input id="firstName" placeholder="请输入姓" />
		</div>
		<div>
			<span>名:</span>
			<input id="lastName" placeholder="请输入名" />
		</div>
		<div>
			<span>姓名: </span>
			<span id="fullName"></span>
		</div>
	</div>

	<script>
		const firstName = document.getElementById('firstName');
		const lastName = document.getElementById('lastName');
		const fullName = document.getElementById('fullName');

		const data = new Proxy(
			{
				firstName: '',
				lastName: '',
				fullName: ''
			},
			{
				/**
				 * 在执行赋值操作时会触发该函数
				 */
				set(obj, prop, newValue) {
					// 将新值赋值给原始对象
					obj[prop] = newValue;
					// 并对不同的属性触发不同的操作
					if (prop == 'firstName') {
						firstName.value = data.firstName;
						updateFullName();
					} else if (prop == 'lastName') {
						lastName.value = data.lastName;
						updateFullName();
					} else if (prop == 'fullName') {
						fullName.innerText = data.fullName;
					}
				}
			}
		);

		function updateFullName() {
			data.fullName = data.firstName + data.lastName;
			// 将更新的操作移动到了 set 函数内
		}

		firstName.addEventListener('input', (e) => {
			data.firstName = e.target.value;
		});

		lastName.addEventListener('input', (e) => {
			data.lastName = e.target.value;
		});

		// 测试同步效果
		data.firstName = '姓';
		data.lastName = '名';

		console.log(data);
	</script>
</body>
```

以下是功能展示，此时三个变量都已经正确同步了，在修改变量时也可以保持同步状态，这非常好。

<iframe src="/frame/发布订阅2" class="shadow-lg border border-gray-200 w-full mx-auto h-auto p-10" ></iframe>

让我们观察这个`set`函数，我们在定义函数时就需要知道要同步哪些数据到哪部分的视图中去。实际上，应用中的数据和视图都是非常多的，这个函数实现将变得非常繁琐，而且很容易出错。

让我们先梳理一下上述的过程，将每个过程都拆分的细致一些：

1. 修改`firstName`时, 要执行两种操作
   - 将`firstName`更新到视图中
   - 重新计算`fullName`
2. 修改`lastName`时, , 要执行两种操作
   - 将`lastName`更新到视图中
   - 重新计算`fullName`
3. 修改`fullName`时, 只要执行一种动作
   - 将`fullName`更新到视图中

### 步骤三 发布订阅

将操作直接写入`set`函数中灵活性太差了，要解决这个问题，可以使用发布订阅模式，每次调用`set`方法就表示发布，发布时会触发所有订阅，订阅可以随时解除或者新增，下面是一个简单实现。

```html
<body>
	<div>
		<div>
			<span>姓:</span>
			<input id="firstName" placeholder="请输入姓" />
		</div>
		<div>
			<span>名:</span>
			<input id="lastName" placeholder="请输入名" />
		</div>
		<div>
			<span>姓名: </span>
			<span id="fullName"></span>
		</div>
	</div>

	<script>
		const firstName = document.getElementById('firstName');
		const lastName = document.getElementById('lastName');
		const fullName = document.getElementById('fullName');

		const data = new Proxy(
			{
				firstName: '',
				lastName: '',
				fullName: ''
			},
			{
				set(obj, prop, newValue) {
					const oldValue = obj[prop];
					obj[prop] = newValue;
					/**
					 * 通过发布订阅模式触发对应的事件
					 */
					dataEvents.update(prop, newValue, oldValue);
				}
			}
		);

		/**
		 * 发布订阅器
		 * 核心就是为每个属性维护了一个函数执行数组
		 * 这样就可以通过 push 操作添加订阅
		 */
		const dataEvents = {
			update(prop, newValue, oldValue) {
				dataEvents[prop].forEach((cb) => {
					cb(newValue, oldValue);
				});
			},
			firstName: [],
			lastName: [],
			fullName: []
		};

		/**
		 * 添加函数订阅，对于每个属性都可以单独订阅
		 */
		dataEvents.firstName.push(function (newValue) {
			firstName.value = newValue;
		});

		dataEvents.firstName.push(function (newValue) {
			data.fullName = data.firstName + data.lastName;
		});

		dataEvents.lastName.push(function (newValue) {
			lastName.value = newValue;
		});

		dataEvents.lastName.push(function (newValue) {
			data.fullName = data.firstName + data.lastName;
		});

		dataEvents.fullName.push(function (newValue) {
			fullName.innerText = newValue;
		});

		firstName.addEventListener('input', (e) => {
			data.firstName = e.target.value;
		});

		lastName.addEventListener('input', (e) => {
			data.lastName = e.target.value;
		});

		data.firstName = '姓';
		data.lastName = '名';

		// 这段代码可以先注释掉，通过在控制套粘贴也是可以被触发的
		dataEvents.fullName.push(function (newValue, oldValue) {
			console.log(`将 fullName 从 ${oldValue} 变更为 ${newValue}`);
		});

		console.log(dataEvents);
	</script>
</body>
```

以下是功能展示，此时可以在数据定义之外添加新的订阅了，我们离目标又近了一步。

<iframe src="/frame/发布订阅3" class="shadow-lg border border-gray-200 w-full mx-auto h-auto p-10" ></iframe>

### 步骤四 订阅整合

从上一个示例中我们发现，`firstName` 和 `lastName` 都会触发`fullName`的修改，这被称作派生或者计算变量。而在真实的场景中，派生变量可能会依赖更多的变量，让我们把这种计算过程整合到一起吧。也就是编写一个`watch`函数，函数参数分别是要触发的函数以及需要监听的属性列表。

```html
<body>
	<div>
		<div>
			<span>姓:</span>
			<input id="firstName" placeholder="请输入姓" />
		</div>
		<div>
			<span>名:</span>
			<input id="lastName" placeholder="请输入名" />
		</div>
		<div>
			<span>姓名: </span>
			<span id="fullName"></span>
		</div>
	</div>

	<script>
		const firstName = document.getElementById('firstName');
		const lastName = document.getElementById('lastName');
		const fullName = document.getElementById('fullName');

		const data = new Proxy(
			{
				firstName: '',
				lastName: '',
				fullName: ''
			},
			{
				set(obj, prop, newValue) {
					obj[prop] = newValue;
					dataEvents.update(prop);
				}
			}
		);

		const dataEvents = {
			update(prop, newValue, oldValue) {
				dataEvents[prop].forEach((cb) => {
					cb();
				});
			},
			firstName: [],
			lastName: [],
			fullName: []
		};

		/**
		 * 定义监听函数
		 */
		function watch(cb, propers) {
			propers.forEach((prop) => {
				dataEvents[prop].push(cb);
			});
		}

		watch(
			function (newValue) {
				firstName.value = data.firstName;
			},
			['firstName']
		);

		watch(
			function () {
				data.fullName = data.firstName + data.lastName;
			},
			['firstName', 'lastName']
		);

		watch(
			function () {
				lastName.value = data.lastName;
			},
			['lastName']
		);

		watch(
			function () {
				fullName.innerText = data.fullName;
			},
			['fullName']
		);

		firstName.addEventListener('input', (e) => {
			data.firstName = e.target.value;
		});

		lastName.addEventListener('input', (e) => {
			data.lastName = e.target.value;
		});

		data.firstName = '姓';
		data.lastName = '名';

		console.log(dataEvents);
	</script>
</body>
```

以下是功能展示，显然重构后代码逻辑更加一致了，而且保持了原有页面功能。

<iframe src="/frame/发布订阅4" class="shadow-lg border border-gray-200 w-full mx-auto h-auto p-10" ></iframe>

### 步骤五 依赖收集

我们离成功只有一步之遥了，但此时会碰到一个困扰了我很久的难题-`依赖收集`。所谓依赖收集，就是去除掉`watch`的第二个函数参数，从函数实现中我们可以观察到，第二个函数参数数组实际上是冗余的，`哪个属性变化会触发函数`已经包含实现中了。这个问题为什么困难呢？

1. 访问属性时怎么触发事件呢？`Proxy`的`get`方法可以自动触发
2. `get`触发时，怎么获取到要执行的函数以进行订阅呢？答案是使用全局变量

```html
<body>
	<div>
		<div>
			<span>姓:</span>
			<input id="firstName" placeholder="请输入姓" />
		</div>
		<div>
			<span>名:</span>
			<input id="lastName" placeholder="请输入名" />
		</div>
		<div>
			<span>姓名: </span>
			<span id="fullName"></span>
		</div>
	</div>

	<script>
		const firstName = document.getElementById('firstName');
		const lastName = document.getElementById('lastName');
		const fullName = document.getElementById('fullName');

		/**
		 * 定义全局监听变量，每次调用watch时修改改属性
		 * 同时该变量会在`get`时被绑定
		 */
		let currentSubcribe = null;

		const data = new Proxy(
			{
				firstName: '',
				lastName: '',
				fullName: ''
			},
			{
				/**
				 * 添加获取监听
				 */
				get(obj, prop) {
					if (currentSubcribe) {
						dataEvents[prop].push(currentSubcribe);
					}
					return obj[prop];
				},
				set(obj, prop, newValue) {
					obj[prop] = newValue;
					dataEvents.update(prop);
				}
			}
		);

		const dataEvents = {
			update(prop, newValue, oldValue) {
				dataEvents[prop].forEach((cb) => {
					cb();
				});
			},
			firstName: [],
			lastName: [],
			fullName: []
		};

		/**
		 * 定义监听函数
		 */
		function watch(cb) {
			currentSubcribe = cb;
			cb();
			currentSubcribe = null;
		}

		watch(function (newValue) {
			firstName.value = data.firstName;
		});

		watch(function () {
			data.fullName = data.firstName + data.lastName;
		});

		watch(function () {
			lastName.value = data.lastName;
		});

		watch(function () {
			fullName.innerText = data.fullName;
		});

		firstName.addEventListener('input', (e) => {
			data.firstName = e.target.value;
		});

		lastName.addEventListener('input', (e) => {
			data.lastName = e.target.value;
		});

		data.firstName = '姓';
		data.lastName = '名';

		console.log(dataEvents);
	</script>
</body>
```

以下是功能展示，这就是视图模型的全部功能了。

<iframe src="/frame/发布订阅5" class="shadow-lg border border-gray-200 w-full mx-auto h-auto p-10" ></iframe>

到这里我们的讲解就结束了，当然这里只是最简化的一个版本。

更复杂的功能可以查看`rxjs`的实现，或者其他基于`signals`实现的信号量机制，如`solid-js`或者`preact`等。

